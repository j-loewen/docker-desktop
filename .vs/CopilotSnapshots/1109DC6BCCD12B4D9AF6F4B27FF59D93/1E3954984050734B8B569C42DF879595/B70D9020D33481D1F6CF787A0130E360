using Docker.DotNet;
using Docker.DotNet.Models;
using System.Diagnostics;
using Microsoft.Maui.Controls;
using System.Linq;
using System.Threading.Tasks;

namespace DockerDesktop.Services;
public class DockerService {

    //https://github.com/dotnet/Docker.DotNet

    private readonly SettingsService settingsService;
    private Docker.DotNet.DockerClient? client;

    public ObservableCollection<ContainerListResponse> Container { get; } = new();
    public ObservableCollection<ImagesListResponse> Images { get; } = new();
    public ObservableCollection<NetworkResponse> Networks { get; } = new();
    public ObservableCollection<VolumesListResponse> Volumes { get; } = new();
    public SystemInfoResponse SystemInfo { get; set; } = new();

    public DockerService(SettingsService settingsService) {
        this.settingsService = settingsService;
    }

    public async Task Connect() {
        this.client = new DockerClientConfiguration(new Uri(this.settingsService.Settings.Host)).CreateClient();

        this.SystemInfo = await client.System.GetSystemInfoAsync();

        await this.LoadContainersAsync();
        await this.LoadImagesAsync();
        await this.LoadNetworksAsync();
        await this.LoadVolumesAsync();
    }

    public async Task LoadContainersAsync() {
        if (this.client == null) {
            throw new InvalidOperationException("Docker client is not connected. Call Connect() first.");
        }

        IList<ContainerListResponse> containers = await this.client.Containers.ListContainersAsync(new ContainersListParameters() {
            All = true
        });

        // Get container stats for running containers
        foreach (var container in containers.Where(c => c.State == "running")) {
            try {
                CancellationToken cancellationToken = new CancellationToken();
                var stats = await this.client.Containers.GetContainerStatsAsync(container.ID, new ContainerStatsParameters());

                // Update container CPU and memory stats
                if (stats != null) {
                    // Calculate CPU percentage
                    var cpuDelta = stats.CPUStats.CPUUsage.TotalUsage - stats.PreCPUStats.CPUUsage.TotalUsage;
                    var systemDelta = stats.CPUStats.SystemUsage - stats.PreCPUStats.SystemUsage;
                    if (systemDelta > 0.0) {
                        container.CPUPerc = $"{(cpuDelta / systemDelta * 100.0):F2}%";
                    }

                    // Calculate memory usage
                    container.SizeRootFs = stats.MemoryStats.Usage;
                }
            } catch (Exception ex) {
                Debug.WriteLine($"Error getting stats for container {container.ID}: {ex.Message}");
            }
        }

        MainThread.BeginInvokeOnMainThread(() => {
            // Update container collection
            foreach (var container in containers) {
                var existingContainer = this.Container.FirstOrDefault(c => c.ID == container.ID);
                if (existingContainer != null) {
                    var index = this.Container.IndexOf(existingContainer);
                    this.Container[index] = container;
                } else {
                    this.Container.Add(container);
                }
            }

            // Remove containers that no longer exist
            var containersToRemove = this.Container
                .Where(c => !containers.Any(nc => nc.ID == c.ID))
                .ToList();

            foreach (var container in containersToRemove) {
                this.Container.Remove(container);
            }
        });
    }

    public async Task LoadImagesAsync() {
        if (this.client == null) {
            throw new InvalidOperationException("Docker client is not connected. Call Connect() first.");
        }

        IList<ImagesListResponse> images = await this.client.Images.ListImagesAsync(new ImagesListParameters() {
            All = true
        });

        foreach (var image in images) {
            Boolean found = false;

            for (int i = 0; i < this.Images.Count; i++) {
                if (this.Images[i].ID == image.ID) {
                    this.Images[i] = image;
                    found = true;

                    break;
                }
            }

            if (!found) {
                this.Images.Add(image);
            }
        }

        foreach (var image in this.Images) {
            Boolean found = false;

            for (int i = 0; i < images.Count; i++) {
                if (images[i].ID == image.ID) {
                    found = true;

                    break;
                }
            }

            if (!found) {
                this.Images.Remove(image);
            }
        }
    }

    public async Task LoadNetworksAsync() {
        if (this.client == null) {
            throw new InvalidOperationException("Docker client is not connected. Call Connect() first.");
        }

        IList<NetworkResponse> networks = await this.client.Networks.ListNetworksAsync(new NetworksListParameters() { });

        foreach (var network in networks) {
            Boolean found = false;

            for (int i = 0; i < this.Networks.Count; i++) {
                if (this.Networks[i].ID == network.ID) {
                    this.Networks[i] = network;
                    found = true;

                    break;
                }
            }

            if (!found) {
                this.Networks.Add(network);
            }
        }

        foreach (var network in this.Networks) {
            Boolean found = false;

            for (int i = 0; i < networks.Count; i++) {
                if (networks[i].ID == network.ID) {
                    found = true;

                    break;
                }
            }

            if (!found) {
                this.Networks.Remove(network);
            }
        }
    }

    public async Task LoadVolumesAsync() {
        if (this.client == null) {
            throw new InvalidOperationException("Docker client is not connected. Call Connect() first.");
        }

        VolumesListResponse volumes = await this.client.Volumes.ListAsync(new VolumesListParameters() { });
    }
}
